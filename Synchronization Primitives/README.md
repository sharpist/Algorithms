#				SpinWait
```
Lock-free программирование с помощью SpinWait – это одна из наиболее сложных техник в
многопоточном программировании, которая используется тогда, когда никакие другие, более
высокоуровневые, конструкции не способны решить поставленную задачу.
```
_________________________________________________________________________________________

SpinWait помогает в разработке lock-free кода, который крутится в цикле (spins), а не
блокируется.
Это достигается путем реализации особых мер, предотвращающих ресурсное голодание
(resource starvation) и инверсию приоритета (priority inversion), которые могут возникать
в случае ожидания в цикле (spinning).

#### Если ожидание в цикле загрузит все ядра процессора (n число потоков в петле) ####
#### произойдёт замедление работы остальных потоков вследствие ресурсного голодания. ####

#### Это приведёт к инверсии приоритетов и замедлению выполнения того потока, который ####
#### установит флаг true. ####


Структура SpinWait решает эту проблему двумя путями:

1. Ограничивает ресурсоёмкие циклы до определенного количества итераций, по истечению
которых квант времени, выделенный текущему потоку, прерывается на каждой последующей
итерации (путём вызова метода Thread.Yield и Thread.Sleep), снижая тем самым
потребление ресурсов.

2. Определяет, происходит ли выполнение на одноядерном компьютере, и если это так, то
прерывает выполнение каждого цикла.

#### Как использовать SpinWait: ####
*создать экземпляр структуры с последующим вызовом SpinOnce в цикле
```
bool _proceed; // флаг
void Test()
{
    var spinWait = new SpinWait();
    while (!_proceed)
    {
        Thread.MemoryBarrier();
        spinWait.SpinOnce();
    }
}
```

#### Как работает SpinWait: ####
В текущей реализации SpinWait выполняет 10 итераций, прежде чем произойдёт переключение
контекста. Однако управление не возвращается немедленно после каждого такого цикла:
вместо этого вызывается метод Thread.SpinWait для ожидания с помощью CLR (и, в конечном
итоге, операционной системы) на указанный период времени.

Изначально этот период составляет несколько десятков наносекунд, но он увеличивается
вдвое на каждой итерации, пока не будет выполнено 10 итераций.
Это даёт некоторую предсказуемость того, какое количество времени будет потрачено в
процессороёмкой фазе цикла, и CLR или операционная система могут изменять это время в
зависимости от некоторых условий. Обычно этот период составляет несколько десятков
микросекунд, это немного, но больше, чем затраты на переключение контекста.

На одноядерном компьютере SpinWait переключает контекст выполнения на каждой итерации.
Можно проверить, будет ли SpinWait прерывать выполнение потока при следующем вызове с
помощью свойства NextSpinWillYield.

Если SpinWait будет оставаться в режиме «ожидания/переключения» (“spin-yielding”)
достаточно долго (порядка 20 циклов), то он периодически начнет вызвать Thread.Sleep на
несколько миллисекунд, для ещё большего сберегания ресурсов, что поможет выполнять
полезную работу другим потокам.

#### С помощью SpinWait можно продолжить выполнение, предполагая отсутствие конкуренции. ####
Если значение разделяемого поля изменено другим потоком, можно пробовать выполнить
эту же операцию еще раз.
Лучше тратить ресурсы процессора на что-то, что может выполниться, нежели тратить время
процессора на блокировку.


#				Lock-free обновления с помощью SpinWait и Interlocked.CompareExchange
#### Пример: ####
*такой способ не является потокобезопасным
```
x = x * 10;
```
*корректный способ выполнения этой операции без блокировок
1. Получить копию значения x в локальную переменную.
2. Вычислить новое значение.
3. Записать вычисленное значение, если значение переменной за это время не изменилось
   (необходимо выполнить атомарно путем вызова Interlocked.CompareExchange).
4. Если значение локальной переменной устарело, выполнить ожидание в цикле (spin) и
   перейти к шагу 1.
```
int x;

void MultiplyXBy(int factor)
{
    var spinWait = new SpinWait();
    while (true)
    {
        int snapshot1 = x;

        Thread.MemoryBarrier(); // синхронизирует доступ к памяти
                                // в данном случае не обязательно
        int calc = snapshot1 * factor;
        int snapshot2 = Interlocked.CompareExchange(ref x, calc, snapshot1);
        if (snapshot1 == snapshot2) return;
        spinWait.SpinOnce();
    }
}
```

*CompareExchange перегружен, для реализации lock-free обновления любых ссылочных типов:
```
void LockFreeUpdate<T>(ref T field, Func<T, T> updateFunction) where T : class
{
    var spinWait = new SpinWait();
    while (true)
    {
        T snapshot1 = field;

        T calc = updateFunction(snapshot1);
        T snapshot2 = Interlocked.CompareExchange(ref field, calc, snapshot1);
        if (snapshot1 == snapshot2) return;
        spinWait.SpinOnce();
    }
}
```

