#### Содержание: ####

[ДОПОЛНЕНИЕ](https://github.com/sharpist/C_Sharp/tree/master/Synchronization%20Primitives#ДОПОЛНЕНИЕ)

[SpinWait](https://github.com/sharpist/C_Sharp/tree/master/Synchronization%20Primitives#spinwait)

[Lock-free обновления с помощью SpinWait и Interlocked.CompareExchange](https://github.com/sharpist/C_Sharp/tree/master/Synchronization%20Primitives#lock-free-обновления-с-помощью-spinwait-и-interlockedcompareexchange)

#				SpinWait
```
Lock-free программирование с помощью SpinWait – это одна из наиболее сложных техник в
многопоточном программировании, которая используется тогда, когда никакие другие, более
высокоуровневые, конструкции не способны решить поставленную задачу.
```
_________________________________________________________________________________________

SpinWait помогает в разработке lock-free кода, который крутится в цикле (spins), а не
блокируется.
Это достигается путем реализации особых мер, предотвращающих ресурсное голодание
(resource starvation) и инверсию приоритета (priority inversion), которые могут возникать
в случае ожидания в цикле (spinning).

#### Если ожидание в цикле загрузит все ядра процессора (n число потоков в петле) ####
#### произойдёт замедление работы остальных потоков вследствие ресурсного голодания. ####

#### Это приведёт к инверсии приоритетов и замедлению выполнения того потока, который ####
#### установит флаг true. ####


Структура SpinWait решает эту проблему двумя путями:

1. Ограничивает ресурсоёмкие циклы до определенного количества итераций, по истечению
которых квант времени, выделенный текущему потоку, прерывается на каждой последующей
итерации (путём вызова метода Thread.Yield и Thread.Sleep), снижая тем самым
потребление ресурсов.

2. Определяет, происходит ли выполнение на одноядерном компьютере, и если это так, то
прерывает выполнение каждого цикла.

#### Как использовать SpinWait: ####
*создать экземпляр структуры с последующим вызовом SpinOnce в цикле
```
bool _proceed; // флаг
void Test()
{
    var spinWait = new SpinWait();
    while (!_proceed)
    {
        Thread.MemoryBarrier();
        spinWait.SpinOnce();
    }
}
```

#### Как работает SpinWait: ####
В текущей реализации SpinWait выполняет 10 итераций, прежде чем произойдёт переключение
контекста. Однако управление не возвращается немедленно после каждого такого цикла:
вместо этого вызывается метод Thread.SpinWait для ожидания с помощью CLR (и, в конечном
итоге, операционной системы) на указанный период времени.

Изначально этот период составляет несколько десятков наносекунд, но он увеличивается
вдвое на каждой итерации, пока не будет выполнено 10 итераций.
Это даёт некоторую предсказуемость того, какое количество времени будет потрачено в
процессороёмкой фазе цикла, и CLR или операционная система могут изменять это время в
зависимости от некоторых условий. Обычно этот период составляет несколько десятков
микросекунд, это немного, но больше, чем затраты на переключение контекста.

На одноядерном компьютере SpinWait переключает контекст выполнения на каждой итерации,
в многопроцессорной системе SpinOnce может уступить после неуказанного числа вызовов.
Можно проверить, будет ли SpinWait прерывать выполнение потока при следующем вызове с
помощью свойства ```NextSpinWillYield``` – возвращает признак того, приведёт ли следующий
вызов SpinOnce к принудительному переключению контекста.

Если SpinWait будет оставаться в режиме «ожидания/переключения» (“spin-yielding”)
достаточно долго (порядка 20 циклов), то он периодически начнет вызвать Thread.Sleep на
несколько миллисекунд, для ещё большего сберегания ресурсов, что поможет выполнять
полезную работу другим потокам.

#### С помощью SpinWait можно продолжить выполнение, предполагая отсутствие конкуренции. ####
Если значение разделяемого поля изменено другим потоком, можно пробовать выполнить
эту же операцию еще раз.
Лучше тратить ресурсы процессора на что-то, что может выполниться, нежели тратить время
процессора на блокировку.


#				Lock-free обновления с помощью SpinWait и Interlocked.CompareExchange
#### Пример: ####
*такой способ не является потокобезопасным
```
x = x * 10;
```
*корректный способ выполнения этой операции без блокировок
1. Получить копию значения ```x``` в локальную переменную.
2. Вычислить новое значение.
3. Записать вычисленное значение, если значение переменной за это время не изменилось
   (необходимо выполнить атомарно путем вызова Interlocked.CompareExchange).
4. Если значение локальной переменной устарело, выполнить ожидание в цикле (spin) и
   перейти к шагу 1.
```
int x;

void MultiplyXBy(int factor)
{
    var spinWait = new SpinWait();
    while (true)
    {
        int snapshot1 = x;

        Thread.MemoryBarrier(); // синхронизирует доступ к памяти
                                // в данном случае не обязательно
        int calc = snapshot1 * factor;
        int snapshot2 = Interlocked.CompareExchange(ref x, calc, snapshot1);
        if (snapshot1 == snapshot2) return;
        spinWait.SpinOnce();
    }
}
```

*CompareExchange перегружен, для реализации lock-free обновления любых ссылочных типов:
```
void LockFreeUpdate<T>(ref T field, Func<T, T> updateFunction) where T : class
{
    var spinWait = new SpinWait();
    while (true)
    {
        T snapshot1 = field;

        T calc = updateFunction(snapshot1);
        T snapshot2 = Interlocked.CompareExchange(ref field, calc, snapshot1);
        if (snapshot1 == snapshot2) return;
        spinWait.SpinOnce();
    }
}
```


#				ДОПОЛНЕНИЕ
#### Отличие Thread.Sleep() от Thread.SpinWait(): ####
Оба метода позволяют приостановить исполнение текущего потока.

#### Thread.Sleep() ####
не только блокирует текущий поток, но и сообщает планировщику потоков
Windows о том, что текущий поток освобождает причитающийся ему квант процессорного
времени (time slice), поэтому планировщик может передать этот квант следующему потоку
в очереди.
Так поток на протяжении всего этого промежутка практически не будет потреблять
процессорное время. При обходе очереди потоков, ожидающих своего кванта процессорного
времени, планировщик будет просто пропускать этот поток.

_________________________________________________________________________________________
#### Thread.SpinWait() ####
отличается тем, что здесь не происходит переключение контекста потока,
текущий поток не передаёт управление планировщику Windows.
Вместо этого, внутри метода SpinWait() запускается холостой цикл, число итераций
передаётся в параметре метода.
```
Соответственно, время ожидания SpinWait() будет незначительным даже по сравнению с
вызовом Sleep(1). Так как согласно утверждению Джо Даффи, только переключение контекста
потоков занимает 4000+ процессорных тактов!
```

Выгодно применять когда потоку необходимо "минимальное ожидание", не передавая при этом
управления другим потокам (за время исполнения SpinWait() планировщик может прервать
текущий поток, но SpinWait() этого "не заметит").
Обычно SpinWait() используют в "тонких" техниках неблокирующих алгоритмов, когда ценой
потери нескольких сот тактов можно избежать переключения контекста при явной блокировке
или вызове Sleep(), а также связанных с ними проблем обновления кэша.
