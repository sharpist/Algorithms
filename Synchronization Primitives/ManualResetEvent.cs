using System;
using System.Threading;

namespace Example
{
    class MyThread
    {
        Thread thread; ManualResetEvent mre;
        // конструктор
        public MyThread(string name, ManualResetEvent evt) {
            thread = new Thread(this.Run);
            thread.Name = name;
            mre = evt;
            thread.Start();
        }

        private void Run() // имитируем работу
        {
            Console.WriteLine("Внутри потока " + thread.Name);

            for (int i = 0; i < 4; i++) {
                Console.WriteLine(thread.Name); Thread.Sleep(1000);
            }

            Console.WriteLine(thread.Name + " завершен!");
            // уведомление о событии
            mre.Set();
        }
    }


    class Program
    {
        static void Main()
        {
            var mt1 = new MyThread("Событийный поток 1", evtObt); // false

            Console.WriteLine("Основной поток ожидает событие");
            evtObt.WaitOne();

            Console.WriteLine("Основной поток получил уведомление о событии от первого потока");
            evtObt.Reset(); // again false!


            var mt2 = new MyThread("Событийный поток 2", evtObt);

            Console.WriteLine("Основной поток ожидает событие");
            evtObt.WaitOne();

            Console.WriteLine("Основной поток получил уведомление о событии от второго потока");
            Console.ReadLine();
        }
        // объект-событие
        static ManualResetEvent evtObt = new ManualResetEvent(false);
    }
}

/// Поток, ожидающий некоторое событие, вызывает метод WaitOne() для событийного объекта, представляющего данное событие.
/// Если событийный объект находится в сигнальном состоянии, то происходит немедленный возврат из метода WaitOne().
/// В противном случае выполнение вызывающего потока приостанавливается до тех пор, пока не будет получено уведомление о событии.
/// Как только событие произойдет в другом потоке, этот поток установит событийный объект в сигнальное состояние, вызвав метод Set().
/// Поэтому метод Set() следует рассматривать как уведомляющий о том, что событие произошло.
/// После установки событийного объекта в сигнальное состояние произойдет немедленный возврат из метода WaitOne(),
/// и первый поток возобновит свое выполнение. А в результате вызова метода Reset() событийный объект возвращается в несигнальное состояние.
/// 
/// Событийный объект устанавливается в исходное состояние и весь процесс повторяется, но на этот раз для второго потока.
/// Если бы не событийный объект, то все потоки выполнялись бы одновременно, а результаты их выполнения оказались бы окончательно запутанными!
/// 
///
/// Событие AutoResetEvent отличается от события типа ManualResetEvent способом установки в исходное состояние.
/// Для события типа AutoResetEvent событийный объект автоматически переходит в несигнальное состояние, как только поток,
/// ожидающий это событие, получит уведомление о нем и возобновит свое выполнение.
/// Поэтому вызывать метод Reset() необязательно.
