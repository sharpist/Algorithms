Sorting Algorithms
Устойчивая и неустойчивая реализации: Если массив до сортировки { (2, a), (2, b), (1, a) }
и после сортировки { (1, a), (2, b), (2, a) } взаимное расположение элементов
(2, a) и (2, b) изменилось, соответственно реализация неустойчивая.


- Bubble sort (Сортировка пузырьком, метод сортировки обменами) алгоритм справился за 1 м. с 100000 элементов

            for (byte i = 0; i < arr.Length - 1; i++)
            {
                byte f = 0; // флаг сократит кол-во проходов, если перестановок не производилось

                for (byte j = 0; j < arr.Length - i - 1; j++) // взята i так как с каждой итерацией основного цикла один элемент отсортировывается (передвигается вправо)
                {      // j отсчитывает индексы в arr
                    if (arr[j] > arr[j + 1])  // если первое число j больше второго числа j+1, тогда они меняются местами:
                    {
                        int buf = arr[j + 1]; // второе число j+1 сохраняется в buf
                        arr[j + 1] = arr[j];  // первое число j замещает второе j+1
                        arr[j] = buf;         // из buf второе число j+1 замещает первое j
                        f = 1;
                    }
                }
                if (f == 0) break;
            }










- Selection sort (Сортировка выбором) алгоритм справился за 30 с. с 100000 элементов
Может быть как устойчивый, так и неустойчивый. Для реализации устойчивости алгоритма необходимо минимальный
элемент вставлять в первую неотсортированную позицию, не меняя порядок остальных элементов.

            int buf;
            int min;

            for (int i = 0; i < arr.Length - 1; i++)
            {
                min = i; // каждую итерацию (внешнего цикла) min отступает (вправо) на позицию и просматривает следующую
                for (int max = i + 1; max < arr.Length; max++) // i + 1 гарантирует высший индекс позиции для max
                {
                    if (arr[min] > arr[max]) // [4][3] 2  5  1    4 [3][2] 5  1    4  3 [2][5] 1    4  3 [2] 5 [1]
                    {                        //  0 (1) 2  3  4    0  1 (2) 3  4    0  1 (2) 3  4    0  1  2  3 (4)
                        min = max; // последовательным сравнением min с max определяется наименьшее число
                    }              // индекс которого сохраняется в min
                }                  // найденное наименьшее значение переставляется в начало (влево) и исключается из проверки (оно упорядочено)!
                if (min != i)
                {
                    buf = arr[i];      // буфер сохраняет значение принадлежащее индексу позиции 0
                    arr[i] = arr[min]; // наименьшим значением замещается значение позиции 0
                    arr[min] = buf;    // сохранённым значением замещается позиция наименьшего значения
                }                      // значения обменялись местами
            }










- Insertion sort (Сортировка вставками) алгоритм справился за 19 с. с 100000 элементов

            for (int max = 1; max < arr.Length; max++)
            {
                int min;
                int buf = arr[max];
                for (min = max - 1; min >= 0; min--)   //          b                         b                       b
                {                                      //         [3]                       [2]                     [2]
                    if (arr[min] < buf)                // 1.   [4] 3  2  5  1     4.   3 [4] 2  5  1     6.   [3] 4  4  5  1
                        break;                         //       m                         m                    m
                                                       //         [3]                       [2]                     [2]
                    arr[min + 1] = arr[min];           // 2.   [ ][4] 2  5  1     5.   3 [ ][4] 5  1     7.   [ ][3] 4  5  1
                }
                arr[min + 1] = buf; // -1 + 1 = 0                 [ ]                                               [ ]
            }                                          // 3.   [3] 4  2  5  1                            8.   [2] 3  4  5  1




















- Quick sort (Быстрая сортировка, сортировка Хоара) алгоритм справился за 4 с. с 100000 элементов
Неустойчив! Решается расширением ключа исходным индексом элемента в массиве.
При равенстве основных ключей сравнение проходит по индексу, исключая, изменения взаимного положения равных элементов.
Требует дополнительно память и 1 полный проход по массиву.

        // с обобщенными типами, тип Т должен реализовывать интерфейс IComparable<T>
        int partition<T> (T[] m, int a, int b) where T : IComparable<T>
        {
            int i = a;
            for (int j = a; j <= b; j++)           // просматриваем с a по b
            {
                if (m[j].CompareTo(m[b]) <= 0)     // если элемент m[j] не превосходит m[b],
                {
                    T t = m[i];                    // меняем местами m[j] и m[a], m[a+1], m[a+2] и так далее...
                    m[i] = m[j];                   // то есть переносим элементы меньшие m[b] в начало,
                    m[j] = t;                      // а затем и сам m[b] «сверху»
                    i++;                           // таким образом последний обмен: m[b] и m[i], после чего i++
                }
            }
            return i - 1;                          // в индексе i хранится <новая позиция элемента m[b]> + 1
        }

        public void quicksort<T> (T[] m, int a, int b) where T : IComparable<T> // a - начало подмножества, b - конец
        {                                                                       // для первого вызова: a = 0, b = <элементов в массиве> - 1
            if (a >= b) return;
            int c = partition(m, a, b);
            quicksort(m, a, c - 1);
            quicksort(m, c + 1, b);
        }
            // пример вызова
            // double[] arr = {9,1.5,34.4,234,1,56.5};
            // quicksort<double>(arr,0,arr.Length-1);
            //
