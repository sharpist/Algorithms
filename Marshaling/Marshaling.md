# "Маршалинг взаимодействия"

#### Содержание: ####

[Обращение к низкоуровневым dll-библиотекам](https://github.com/sharpist/C_Sharp/blob/master/Marshaling/Marshaling.md#Обращение-к-низкоуровневым-dll-библиотекам)

[Маршализация типов](https://github.com/sharpist/C_Sharp/blob/master/Marshaling/Marshaling.md#Маршализация-типов)

[Маршализация классов/структур](https://github.com/sharpist/C_Sharp/blob/master/Marshaling/Marshaling.md#Маршализация-классовструктур)

[Маршализация параметров in и out](https://github.com/sharpist/C_Sharp/blob/master/Marshaling/Marshaling.md#Маршализация-параметров-in-и-out)

[...](https://github.com/)
_______________________________________________________________________________
## Обращение к низкоуровневым dll-библиотекам
_______________________________________________________________________________

Для обеспечения интеграции с неуправляемыми dll-библиотеками предусмотрены
службы вызова функций платформы, образующие технологию ```P/Invoke```, которая
позволяет задействовать функции, структуры и обратные вызовы в dll-библиотеках.

Пространство имён ```System.Runtime.InteropServices```.

Например, в dll-библиотеке ```user32.dll``` определена функция ```MessageBox```:
```
int MessageBox(
    HWND    hWnd,
    LPCTSTR lpText,
    LPCTSTR lpCaption,
    UINT    uType
);
```
Данную функцию можно вызвать напрямую.

Объявляется одноименный статический метод с внешней реализацией (при применении
служб взаимодействия для вызова неуправляемого кода модификатор ```extern```
используется с атрибутом ```DllImport```):
```c#
using System;
using System.Runtime.InteropServices;

class Program
{
    public static void Main() =>
        MessageBox(IntPtr.Zero, "Текст", "Заголовок", 0);


    // используется метод MessageBox из библиотеки User32.dll
    [DllImport("user32.dll")]
    public static extern int MessageBox(
        IntPtr hWnd,
        string text,
        string caption,
        int    type
    );
}
```
#### Маршализатор транслирует параметры и возвращаемые значения между типами .NET и неуправляемыми типами. ####

В примере параметры ```int``` преобразуются в четырёхбайтовые целые числа, строковые
 – в массивы двухбайтовых символов Unicode, завершающиеся символом ```null```.
Структура ```IntPtr``` инкапсулирует неуправляемый дескриптор.

Подобное поведение свойственно классам из пространств имён ```System.Windows``` и
```System.Windows.Forms```, которые свободно вызывают неуправляемые методы.
_______________________________________________________________________________
## Маршализация типов
_______________________________________________________________________________

#### На неуправляемой стороне требуемый тип данных может быть представлен разными способами. ####

Строка может содержать однобайтовые символы ANSI или двухбайтовые – Unicode,
начинаться префиксным значением длины и завершаться ```null```, или быть фиксированной
длины.

Поэтому, чтобы маршализатор CLR провёл корректную трансляцию, применяется
атрибут ```MarshalAs```:
```c#
[DllImport("*.dll")]
public static extern int Foo(
    [MarshalAs(UnmanagedType.LPStr)]
    string s
);
```
*перечисление ```UnmanagedType``` содержит все поддерживаемые маршализатором типы


#### На управляемой стороне .NET доступен подобный выбор относительно применяемого типа данных. ####

Неуправляемый дескриптор может отображаться на типы ```IntPtr```, ```int```, ```uint```, ```long``` и
```ulong```.
Дескрипторы, инкапсулирующие указатель или адрес, отображаются на ```IntPtr``` для
совместимости с ОС.

#### Важное отличие составляет необходимость выполнения ряда процессов управления памятью при получении строк обратно из неуправляемого кода в .NET. ####

Тем не менее, маршализатор берёт это на себя, когда внешний метод в качестве
параметра ожидает объект типа ```StringBuilder```, вместо ```string```:
```c#
using System;
using System.Runtime.InteropServices;
using System.Text;

class Program
{
    public static void Main()
    {
        var sb = new StringBuilder(256);
        GetWindowsDirectory(sb, 256);
        Console.WriteLine(sb); // C:\WINDOWS
    }


    [DllImport("kernel32.dll")]
    public static extern int GetWindowsDirectory(
        StringBuilder sb, int maxChars
    );
}
```
_______________________________________________________________________________
## Маршализация классов/структур
_______________________________________________________________________________

Когда в неуправляемый метод требуется передавать в качестве параметра класс или
структуру, например, как тип ```LPSYSTEMTIME``` в методе ```GetSystemTime```:
```c
typedef struct _SYSTEMTIME {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
} SYSTEMTIME, *PSYSTEMTIME;
```
*эквивалентно структуре в C

Необходимо определить соответствующий класс или структуру .NET прямо в
управляемом коде, установив атрибут ```StructLayout```, который укажет маршализатору
способ отображения каждого поля на его неуправляемый эквивалент при помощи
перечисления ```LayoutKind```, определяющего предустановленное поведение размещения
для управляемых классов и структур:

```Sequential``` – поля размещаются в порядке отображения при экспорте, выравниваясь
последовательно по границам размеров пакета, в соответствии с компоновкой,
заданной в ```Pack``` и могут быть несмежными.

```Explicit``` – точное положение каждого поля объекта в неуправляемой памяти
управляется явно в соответствии с настройкой свойства ```Pack```.

```c#
[StructLayout(LayoutKind.Sequential)]
class SystemTime
{
    public ushort Year;
    public ushort Month;
    public ushort DayOfWeek;
    public ushort Day;
    public ushort Hour;
    public ushort Minute;
    public ushort Second;
    public ushort Milliseconds;
}
```

Пример:
```c#
using System;
using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential)]
class SystemTime
{
    public ushort Year;
    public ushort Month;
    public ushort DayOfWeek;
    public ushort Day;
    public ushort Hour;
    public ushort Minute;
    public ushort Second;
    public ushort Milliseconds;
}

class Program
{
    public static void Main()
    {
        var t = new SystemTime();
        GetSystemTime(t);
        Console.WriteLine(t.Year); // 2018
    }


    [DllImport("kernel32.dll")]
    public static extern void GetSystemTime(
        SystemTime t
    );
}
```

Для оптимизации операций доступа в C и C# все поля в объекте размещаются со
смещением в ```n``` байтов, кратным размеру каждого поля, начиная с адреса объекта.

Таким образом, в C имя поля непосредственно компилируется в смещение, в
качестве маркера для представления чего либо по адресу экземпляра типа плюс
взятое смещение, тогда как в C# среда CLR находит смещение применяя маркер поля.

Но из-за ограничения размерности стандартного пакета 8 байтами резервируемая
длина, скажем, структуры, содержащей ```sbyte``` и ```long``` (8 байтов) составит не
ожидаемые 9 байтов, а 16 байтов из которых 7 байтов останутся без нагрузки!

Потери можно минимизировать или устранить задав размер пакета через свойство
```Pack``` в атрибуте ```StructLayout``` – обеспечив выравнивание по смещениям, кратным
выбранному размеру пакета.

При 1-байтовом размере пакета, результирующая резервируемая структурой длина
составит 9 байтов.


#### Рекомендации по объявлению вызовов неуправляемого кода: ####

Так как структуры представляют собой типы значений, а классы – ссылочные типы,
в классах изначально реализовано не менее одного уровня косвенного обращения к
памяти (указатель на значение).

Важное отличие, поскольку неуправляемые функции часто используют косвенное
обращение.

![declarations](01.png)

* если неуправляемая функция не требует косвенного обращения, необходимо
использовать структуру, передаваемую по значению.
* если неуправляемая функция требует один уровень косвенного обращения,
необходимо использовать передаваемую по ссылке структуру или передаваемый по
значению класс.
* если неуправляемая функция требует два уровня косвенного обращения, необходимо
использовать класс, передаваемый по ссылке.
_______________________________________________________________________________
## Маршализация параметров ```in``` и ```out```
_______________________________________________________________________________

