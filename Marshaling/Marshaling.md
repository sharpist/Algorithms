# "Маршалинг взаимодействия"

#### Содержание: ####

[Обращение к низкоуровневым dll-библиотекам](https://github.com/sharpist/C_Sharp/blob/master/Marshaling/Marshaling.md#Обращение-к-низкоуровневым-dll-библиотекам)

[Маршализация типов](https://github.com/sharpist/C_Sharp/blob/master/Marshaling/Marshaling.md#Маршализация-типов)

[Маршализация классов/структур](https://github.com/sharpist/C_Sharp/blob/master/Marshaling/Marshaling.md#Маршализация-классовструктур)

* [Правила выравнивания](https://github.com/sharpist/C_Sharp/blob/master/Marshaling/Marshaling.md#Правила-выравнивания)

* [Рекомендации по объявлению вызовов неуправляемого кода](https://github.com/sharpist/C_Sharp/blob/master/Marshaling/Marshaling.md#Рекомендации-по-объявлению-вызовов-неуправляемого-кода)

[Маршализация параметров in и out](https://github.com/sharpist/C_Sharp/blob/master/Marshaling/Marshaling.md#Маршализация-параметров-in-и-out)

[Обратные вызовы (callback) из неуправляемого кода](https://github.com/sharpist/C_Sharp/blob/master/Marshaling/Marshaling.md#Обратные-вызовы-Callback-из-неуправляемого-кода)

[Эмуляция объединения C](https://github.com/)

[...](https://github.com/)
_______________________________________________________________________________
## Обращение к низкоуровневым dll-библиотекам
_______________________________________________________________________________

Для обеспечения интеграции с неуправляемыми dll-библиотеками предусмотрены
службы вызова функций платформы, образующие технологию ```P/Invoke```, которая
позволяет задействовать функции, структуры и обратные вызовы в dll-библиотеках.

Пространство имён ```System.Runtime.InteropServices```.

Например, в dll-библиотеке ```user32.dll``` определена функция ```MessageBox```:
```
int MessageBox(
    HWND    hWnd,
    LPCTSTR lpText,
    LPCTSTR lpCaption,
    UINT    uType
);
```
Данную функцию можно вызвать напрямую.

Объявляется одноименный статический метод с внешней реализацией (при применении
служб взаимодействия для вызова неуправляемого кода модификатор ```extern```
используется с атрибутом ```DllImport```):
```c#
using System;
using System.Runtime.InteropServices;

class Program
{
    public static void Main() =>
        MessageBox(IntPtr.Zero, "Текст", "Заголовок", 0);


    // используется метод MessageBox из библиотеки user32.dll
    [DllImport("user32.dll")]
    public static extern int MessageBox(
        IntPtr hWnd,
        string text,
        string caption,
        int    type
    );
}
```
#### Маршализатор транслирует параметры и возвращаемые значения между типами .NET и неуправляемыми типами. ####

В примере параметры ```int``` преобразуются в четырёхбайтовые целые числа, строковые
 – в массивы двухбайтовых символов Unicode, завершающиеся символом ```null```.
Структура ```IntPtr``` инкапсулирует неуправляемый дескриптор.

Подобное поведение свойственно классам из пространств имён ```System.Windows``` и
```System.Windows.Forms```, которые свободно вызывают неуправляемые методы.
_______________________________________________________________________________
## Маршализация типов
_______________________________________________________________________________

#### На неуправляемой стороне требуемый тип данных может быть представлен разными способами. ####

Строка может содержать однобайтовые символы ANSI или двухбайтовые – Unicode,
начинаться префиксным значением длины и завершаться ```null```, или быть фиксированной
длины.

Поэтому, чтобы маршализатор CLR провёл корректную трансляцию, применяется
атрибут ```MarshalAs```:
```c#
[DllImport("*.dll")]
public static extern int Foo(
    [MarshalAs(UnmanagedType.LPStr)]
    string s
);
```
*перечисление ```UnmanagedType``` содержит все поддерживаемые маршализатором типы


#### На управляемой стороне .NET доступен подобный выбор относительно применяемого типа данных. ####

Неуправляемый дескриптор может отображаться на типы ```IntPtr```, ```int```, ```uint```, ```long``` и
```ulong```.
Дескрипторы, инкапсулирующие указатель или адрес, отображаются на ```IntPtr``` для
совместимости с ОС.

#### Важное отличие составляет необходимость выполнения ряда процессов управления памятью при получении строк обратно из неуправляемого кода в .NET. ####

Тем не менее, маршализатор берёт это на себя, когда внешний метод в качестве
параметра ожидает объект типа ```StringBuilder```, вместо ```string```:
```c#
using System;
using System.Runtime.InteropServices;
using System.Text;

class Program
{
    public static void Main()
    {
        var sb = new StringBuilder(256);
        GetWindowsDirectory(sb, 256);
        Console.WriteLine(sb); // C:\WINDOWS
    }


    [DllImport("kernel32.dll")]
    public static extern int GetWindowsDirectory(
        StringBuilder sb, int maxChars
    );
}
```
_______________________________________________________________________________
## Маршализация классов/структур
_______________________________________________________________________________

Когда в неуправляемый метод требуется передавать в качестве параметра класс или
структуру, например, как тип ```LPSYSTEMTIME``` в методе ```GetSystemTime```:
```c
typedef struct _SYSTEMTIME {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
} SYSTEMTIME, *PSYSTEMTIME;
```
*эквивалентно структуре в C

Необходимо определить соответствующий класс или структуру .NET прямо в
управляемом коде, установив атрибут ```StructLayout```, который укажет маршализатору
способ отображения каждого поля на его неуправляемый эквивалент при помощи
перечисления ```LayoutKind```, определяющего предустановленное поведение размещения
для управляемых классов и структур:

```Sequential``` – поля размещаются в порядке отображения при экспорте, выравниваясь
последовательно по границам размеров пакета, в соответствии с компоновкой,
заданной в свойстве ```Pack``` и могут быть несмежными.

```Explicit``` – точное положение каждого поля объекта в неуправляемой памяти
управляется явно в соответствии с настройкой свойства ```Pack```.

```c#
[StructLayout(LayoutKind.Sequential)]
class SystemTime
{
    public ushort Year;
    public ushort Month;
    public ushort DayOfWeek;
    public ushort Day;
    public ushort Hour;
    public ushort Minute;
    public ushort Second;
    public ushort Milliseconds;
}
```

Пример 1:
```c#
using System;
using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential)]
class SystemTime
{
    public ushort Year;
    public ushort Month;
    public ushort DayOfWeek;
    public ushort Day;
    public ushort Hour;
    public ushort Minute;
    public ushort Second;
    public ushort Milliseconds;
}

class Program
{
    public static void Main()
    {
        var t = new SystemTime();
        GetSystemTime(t);
        Console.WriteLine(t.Year); // 2018
    }


    [DllImport("kernel32.dll")]
    public static extern void GetSystemTime(
        SystemTime t
    );
}
```

Свойство ```Pack``` задаёт выравнивание полей данных класса или структуры в памяти.
Поддерживаются следующие значения размера пакета: 0, 1, 2, 4, 8, 16, 32, 64 или
128 (где 0 – значение по умолчанию равное 8 байтам).

Для оптимизации операций доступа в C и C# все поля в объекте размещаются со
смещением в ```n``` байтов, кратным размеру каждого поля, начиная с адреса объекта.

Таким образом, в C имя поля непосредственно компилируется в смещение, в
качестве маркера для представления чего либо по адресу экземпляра типа плюс
взятое смещение, тогда как в C# среда CLR находит смещение применяя маркер поля.

Но из-за ограничения размерности стандартного пакета 8 байтами резервируемая
длина, скажем, структуры, содержащей ```sbyte``` и ```long``` (8 байтов) составит не
ожидаемые 9 байтов, а 16 байтов из которых 7 байтов останутся без нагрузки!

Потери можно минимизировать или устранить задав размер пакета через свойство
```Pack``` в атрибуте ```StructLayout``` – обеспечив выравнивание по смещениям, кратным
выбранному размеру пакета.

При однобайтовом размере пакета, результирующая резервируемая структурой длина
составит 9 байтов.

#### Правила выравнивания: ####

1. По умолчанию выравнивание типа – есть размер его наибольшего элемента
(1, 2, 4, 8 и т.д. байтов) или указанный размер пакета, в зависимости от того,
что меньше.

2. Каждое поле необходимо согласовать с полями собственного размера
(1, 2, 4, 8 и т.д. байтов) или c выравниванием типа, в зависимости от того, что
меньше. Поскольку по умолчанию выравнивание типа – есть размер его наибольшего
элемента, это обычно означает, что поля выравниваются по их размеру.

Даже если наибольшее поле в типе является 64-разрядным (8-байтовое) целым
числом или установлен эквивалентный размер пакета в 8 байтов: байтовые поля
выравниваются по однобайтовым границам, ```Int16``` (2-байтовое) выравниваются по
двухбайтовым границам, а ```Int32``` (4-байтовое) выравниваются по четырёхбайтовым
границам.

3. Заполнение добавляется между полями для соответствия требованиям
выравнивания.

Например, структура, состоящая из двух байтовых полей и одиного поля ```Int32```:
```c#
struct Struct
{
    public byte B1, B2;
    public int  I3;
}
```
Если используется размер пакета по умолчанию, тогда величина структуры вмещает
8 байтов. Пара байтовых полей займёт первые два байта памяти, потому что байты
должны выравниваться по однобайтовым границам.

Поскольку выравнивание по умолчанию этого типа входит в 4 байта, то есть размер
его наибольшего из полей – ```I3```, дополнено два байта заполнения, за которым
следует целочисленное поле:
```c#
using System;
using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential, Pack = 0)]
struct Struct
{
    public byte B1, B2;
    public int  I3;
}

class Program
{
    public unsafe static void Main()
    {
        var st = new Struct();
        // указатель на адрес экземпляра типа
        byte* addr = (byte*)&st;

        Console.WriteLine($"Struct size   {sizeof(Struct)} bytes");
        Console.WriteLine($"B1     offset {&st.B1 - addr} bytes");
        // 0x000000cb999edb11 - 0x000000cb999edb10 = 1
        Console.WriteLine($"B2     offset {&st.B2 - addr} bytes");
        Console.WriteLine($"I3     offset {(byte*)&st.I3 - addr} bytes");
    }
}
// Output:
// Struct size   8 bytes
// B1     offset 0 bytes
// B2     offset 1 bytes
// I3     offset 4 bytes
```
Если выбран двухбайтовый пакет, тогда размер структуры составляет 6 байтов. Пара
байтовых полей займёт первые два байта памяти.

Поскольку поля теперь выравниваются по двухбайтовым границам, нет заполнения
между вторым байтом и целым числом:
```c#
...

[StructLayout(LayoutKind.Sequential, Pack = 2)]
struct Struct
{
    public byte B1, B2;
    public int  I3;
}

...
// Output:
// Struct size   6 bytes
// B1     offset 0 bytes
// B2     offset 1 bytes
// I3     offset 2 bytes
```


### Рекомендации по объявлению вызовов неуправляемого кода: ###

Так как структуры представляют собой типы значений, а классы – ссылочные типы,
в классах изначально реализовано не менее одного уровня косвенного обращения к
памяти (указатель на значение).

#### Важное отличие, поскольку неуправляемые функции часто используют косвенное обращение: ####

![declarations](01.png)

* если неуправляемая функция не требует косвенного обращения, необходимо
использовать структуру, передаваемую по значению.
* если неуправляемая функция требует один уровень косвенного обращения,
необходимо использовать передаваемую по ссылке структуру или передаваемый по
значению класс.
* если неуправляемая функция требует два уровня косвенного обращения, необходимо
использовать класс, передаваемый по ссылке.

Пример 2:
```c#
using System;
using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential)]
struct SystemTime
{
    public ushort Year;
    public ushort Month;
    public ushort DayOfWeek;
    public ushort Day;
    public ushort Hour;
    public ushort Minute;
    public ushort Second;
    public ushort Milliseconds;
}

class Program
{
    public static void Main()
    {
        var t = new SystemTime();
        GetSystemTime(ref t);
        Console.WriteLine(t.Year); // 2018
    }


    [DllImport("kernel32.dll")]
    // неуправляемой функции требуется
    // один уровень косвенного обращения
    public static extern void GetSystemTime(
        ref SystemTime t
    );
}
```
В модифицированном примере класс был заменён на структуру, поскольку вызываемой
неуправляемой функции требуется один уровень косвенного обращения, структура
должна передаваться по ссылке.
_______________________________________________________________________________
## Маршализация параметров ```in``` и ```out```
_______________________________________________________________________________

Семантика направленных параметров C# действует равноценно и с внешними методами:

передаваемые по значению и ```in```, ```ref``` и ```in/out```, ```out``` и ```out```.

Типы, запрашивающие копирования при выводе из функции (классы массивов и класс
```StringBuilder```), являются – ```in/out```.
Через атрибуты ```In``` и ```Out``` допускается управление подобным характером.

Например, атрибут ```In``` выставит массив только на чтение, указав, что в функцию
передаётся копия массива и выводиться из не будет:
```c#
[DllImport("*.dll")]
public static extern void Foo(
    [In] int[] array
);
```
_______________________________________________________________________________
## Обратные вызовы (Callback) из неуправляемого кода
_______________________________________________________________________________

В C# дополнительно к вызовам методов C реализованы обратные вызовы из функций C,
через неуправляемые указатели на функции отображаемые на аналог – делегаты C#. 
Уровень ```P/Invoke``` предоставляет отображение между сопряженными конструкциями на
обеих сторонах.

Например, библиотека ```user32.dll``` включает функцию ```EnumWindows```, перечисляющую
значения дескриптора для каждого окна на локальном компьютере (просматривает
список окон).
Конкретная функция ```EnumWindows``` задействует обратный вызов – ```WNDENUMPROC``` и имеет
следующую сигнатуру:
```c
BOOL EnumWindows(WNDENUMPROC lpEnumFunc, LPARAM lParam);
```
Признак обратного вызова – префикс ```lp``` (long pointer) и суффикс ```Func``` в имени
параметра ```lpEnumFunc```, который принимает указатель на функцию обратного вызова.

Обратный вызов определён следующим образом:
```c
BOOL CALLBACK EnumWindowsProc(HWND hwnd, LPARAM lParam);
```
*должен возвращать ```true```, чтобы продолжать перечисление или ```false``` для остановки

Пример:
```c#
using System;
using System.Runtime.InteropServices;

public delegate bool EnumWindowsCallback(IntPtr hWnd, IntPtr lParam);

class Program
{
    public static void Main() =>
        EnumWindows(PrintWindow, IntPtr.Zero);
    // функция обратного вызова
    // запускается пока не вернёт false
    static bool PrintWindow(IntPtr hWnd, IntPtr lParam)
    {
        Console.WriteLine(hWnd.ToInt64());
        return true;
    }

    
    [DllImport("user32.dll")]
    // использовать внешнюю реализацию
    public static extern int EnumWindows(
        // псевдоним PrintWindow
        EnumWindowsCallback hWnd, IntPtr lParam
    );
}
```
*делегат совпадает по сигнатуре с обратным вызовом
_______________________________________________________________________________
## Эмуляция объединения C
_______________________________________________________________________________

