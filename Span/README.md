# Span\<T\>
_________________________________________________________________________________________

### В C# 7.2 ([C# 7.2](https://github.com/sharpist/C_Sharp/tree/master/7.2#c-72)) был добавлен тип ```Span<T>```, который позволяет создать коллекцию данных, хранимую в ###
### стеке, но доступ к которой осуществляется по ссылке. ###
Тип ```Memory<T>``` является расширением типа ```Span<T>``` и используется для потокобезопасного
доступа по ссылке к коллекции хранимой в стеке.

```System.Span<T>``` – это новый тип значений в основе .NET. Который,
делает возможным представление сопредельных областей произвольной
памяти, независимо от того, связана ли эта память с управляемым
объектом, обеспечивается ли она нативным (машинным) кодом,
вызываемым из управляемого кода с помощью Interop или находится в
стеке.
При этом сохраняется безопасный доступ с такими эксплуатационными
характеристиками, как характеристики массивов.

```Span<T>``` является небольшим, но критически важным строительным
блоком для огромных усилий по обеспечению .NET API для разработки
высокопроизводительных серверных приложений с высокой
масштабируемостью.
В отличие от массивов, он может указывать на управляемую или
нативную память, или на память, выделенную в стеке:
```c#
// managed memory
var arrayMemory = new byte[100];
var arraySpan = new Span<byte>(arrayMemory);

// native memory
var nativeMemory = Marshal.AllocHGlobal(100);
Span<byte> nativeSpan;
unsafe
{
    nativeSpan = new Span<byte>(nativeMemory.ToPointer(), 100);
}
SafeSum(nativeSpan);
Marshal.FreeHGlobal(nativeMemory);

// stack memory
Span<byte> stackSpan = stackalloc byte[100];
SafeSum(stackSpan);
```

#### Таким образом, ```Span<T>``` является абстракцией по всем типам памяти, ####
#### доступным для .NET-программ: ####
```c#
// не имеет значения с каким видом памяти работает метод
static ulong SafeSum(Span<byte> bytes)
{
    ulong sum = 0;
    for (int i = 0; i < bytes.Length; i++)
        sum += bytes[i];

    return sum;
}
```

При обёртывании массива ```Span<T>``` не ограничивается указанием на
первый элемент массива. Он может указывать на любой поддиапазон.
Другими словами, он поддерживает резку.
```c#
var array = new byte[] { 1, 2, 3 };
var slice = new Span<byte>(array, start:1, length:2);
Console.WriteLine(slice[0]); // 2
```
Версия ```Span<T>``` только для чтения – ```ReadOnlySpan<T>``` требуется для
представления срезов неизменяемых и доступных только для чтения
структур, например System.String cрезы.

Например, создав ```Span<T>``` из массива:
```c#
var arr = new byte[10];
Span<byte> bytes = arr; // неявное приведение из T[] в Span<T>
```
Можно эффективно создать ```Span``` чтобы представить/указать только
подмножество этого массива, используя перегруженный метод
```Span<T>.Slice```.
Затем индексировать полученный результирующий ```Span``` для записи или
чтения данных в соответствующей уместной части исходного массива:
```c#
Span<byte> slicedBytes = bytes.Slice(start: 5, length: 2);
slicedBytes[0] = 42;
slicedBytes[1] = 43;
Assert.Equal(42, slicedBytes[0]);
Assert.Equal(43, slicedBytes[1]);
Assert.Equal(arr[5], slicedBytes[0]);
Assert.Equal(arr[6], slicedBytes[1]);
slicedBytes[2] = 44; // Throws IndexOutOfRangeException
bytes[2] = 45; // OK
Assert.Equal(arr[2], bytes[2]);
Assert.Equal(45, arr[2]);
```

```Span<T>``` реализован только для стека; точнее, это by-ref тип (как и
его поле в быстрой реализации). Это означает, что ```Span``` не может
быть упакован, не может отображаться как поле типа, отличного от
стека, и не может использоваться в качестве обобщённого аргумента.
Однако ```Span<T>``` может использоваться как тип аргументов метода или
возвращаемых значений.

```Span<T>``` поддерживает переинтерпретацию приведения к ```Span<byte>```. Он
также поддерживает небезопасные приведения между произвольными
примитивными типами. Причина этого ограничения заключается в том,
что некоторые процессоры не поддерживают эффективный невыровненный
доступ к памяти.

В отличие от ```T[]```, ```Span<T>``` не поддерживает ковариантные приведения,
т.е. приведение ```Span<Subtype>``` к ```Span<Basetype>```, не выполняются
проверки ковариации при хранении ссылок в экземплярах ```Span<T>```.

#### Особенности: ####

1. Принудительное ограничение типа только для стека.

* ```Span<T>``` и ```ReadOnlySpan<T>``` включены в набор встроенных типов
только для стека.

* любая другая структура, содержащая один из них, будет транзитивно
считаться типом только для стека.

* компилятор выдаст ошибку, если тип только стека используется в
запрещенном контексте, например, используется в качестве аргумента
типа, помещённого в кучу (упаковка, передается в асинхронный вызов,
используется в качестве поля класса и т.д.).

2. Языковая поддержка для закрепления.
```c#
Span<byte> buffer = ...
fixed(byte* pBuffer = buffer)
{
    ...
}
```

3. Синтаксис среза.

* ```Memory<T>```, ```Span<T>``` и ```ReadOnlySpan<T>``` допускают синтаксис среза.

4. Безопасный ```Span<T>``` stackalloc ([stackalloc](https://github.com/sharpist/C_Sharp/tree/master/Stackalloc#stackalloc)).
```c#
void SafeMethod()
{
    Span<byte> buffer = stackalloc byte[128];
    PrimitiveFormatter.TryFormat(buffer, DateTime.Now, ...);
}
```

5. Примитивное ограничение.

* возможность ограничивать параметры типа примитивными типами
(которые являются битными), некоторые операции ```Span<T>``` допустимы
только для так называемых аргументов примитивного типа, например,
операция переинтерпретации приведения.
```c#
// операция приведения ограничивает параметры типа
public static Span<U> Cast<T, U>(this Span<T> slice) where T:primitive where U:primitive
{ ... }
```
___________________________________________________________________
##			"Неконечные именованные аргументы"
