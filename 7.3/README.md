#			[C# 7.0](https://github.com/sharpist/C_Sharp/tree/master/7.0#c-70) | [C# 7.1](https://github.com/sharpist/C_Sharp/tree/master/7.1#c-71) | [C# 7.2](https://github.com/sharpist/C_Sharp/tree/master/7.2#c-72) | C# 7.3
#### Содержание: ####

ПОВЫШЕНИЕ ПРОИЗВОДИТЕЛЬНОСТИ БЕЗОПАСНОГО КОДА:

[Индексирование полей fixed без закрепления](https://github.com/sharpist/C_Sharp/tree/master/7.3#Индексирование-полей-fixed-без-закрепления)

[Локальные переменные ref могут быть переназначены](https://github.com/sharpist/C_Sharp/tree/master/7.3#Локальные-переменные-ref-могут-быть-переназначены)

[Массивы stackalloc поддерживают инициализаторы](https://github.com/sharpist/C_Sharp/tree/master/7.3#Массивы-stackalloc-поддерживают-инициализаторы)

[Больше типов поддерживают инструкцию fixed](https://github.com/sharpist/C_Sharp/tree/master/7.3#Больше-типов-поддерживают-инструкцию-fixed)

[Расширенные универсальные ограничения](https://github.com/sharpist/C_Sharp/tree/master/7.3#Расширенные-универсальные-ограничения)

УЛУЧШЕНИЕ СУЩЕСТВУЮЩИХ ФУНКЦИЙ:

[Поддержка == и != для кортежей](https://github.com/sharpist/C_Sharp/tree/master/7.3#Поддержка--и--для-кортежей)

[Подключение атрибутов к резервным полям для автоматически реализуемых свойств](https://github.com/sharpist/C_Sharp/tree/master/7.3#Подключение-атрибутов-к-резервным-полям-для-автоматически-реализуемых-свойств)

[...](https://github.com/)

[...](https://github.com/)

___________________________________________________________________
#### ПОВЫШЕНИЕ ПРОИЗВОДИТЕЛЬНОСТИ БЕЗОПАСНОГО КОДА ####
```
Расширяются возможности гарантированно безопасного кода – 
приоритетно использовать безопасные конструкции.
```

##			"Индексирование полей ```fixed``` без закрепления"

Представлена следующая структура с массивом фиксированного размера
([Буферы фиксированного размера](https://github.com/sharpist/C_Sharp/tree/master/Fixed#Буферы-фиксированного-размера)):
```
unsafe struct MyBuffer
{
    public fixed int fixedBuffer[10];
}
```
В более ранних версиях C# переменную необходимо закрепить, чтобы
получить доступ к целым числам, входящим в ```fixedBuffer```:
```
// оператор fixed устанавливает указатель на первый элемент
unsafe void AccessMyBuffer()
{
    fixed (int* intPtr = myBuffer.fixedBuffer)
    {
        int p = intPtr[5];
    }
}
```
Теперь такой код компилируется в безопасном контексте, не требуется
объявлять второй фиксированный указатель ```int* intPtr``` на ```fixedBuffer```.
Контекст ```unsafe``` по-прежнему является обязательным.

Переменная ```p``` обращается к одному элементу в ```fixedBuffer```. Для этого
не нужно объявлять отдельную переменную ```int*```.
```
class MyClass
{
    MyBuffer myBuffer = default;

    unsafe void AccessMyBuffer()
    {
        int p = myBuffer.fixedBuffer[5];
    }
}
```
___________________________________________________________________
##			"Локальные переменные ```ref``` могут быть переназначены"

До версии C# 7.3 ссылочные локальные переменные ([Возвращаемые ссылочные значения](https://github.com/sharpist/C_Sharp/tree/master/Ref%20returns#Возвращаемые-ссылочные-значения-и-ссылочные-локальные-переменные)) не переназначались
после инициализации так, чтобы они ссылались на другое хранилище.
Теперь локальные переменные ```ref``` можно переназначить другим
экземплярам после инициализации:
```
// инициализация
ref VeryLargeStruct refLocal = ref veryLargeStruct;
// переназначение, refLocal ссылается на другое хранилище
refLocal = ref anotherVeryLargeStruct;
```
___________________________________________________________________
##			"Массивы ```stackalloc``` поддерживают инициализаторы"

Синтаксис инициализации массиивов с помощью инициализатора, теперь
применим к массивам, в объявлении которых есть ```stackalloc``` ([stackalloc](https://github.com/sharpist/C_Sharp/tree/master/Stackalloc#stackalloc)):
```
var arr = new int[3] {1, 2, 3};
var arr2 = new int[] {1, 2, 3};

int* pArr = stackalloc int[3] {1, 2, 3};
int* pArr2 = stackalloc int[] {1, 2, 3};
```
___________________________________________________________________
##			"Больше типов поддерживают инструкцию ```fixed```"

Оператор ```fixed``` работает с дополнительными типами, помимо массивов,
строк, буферов фиксированного размера и неуправляемых переменных,
можно применять для ```System.Span<T>``` и связанных типов.

Любой тип, реализующий метод ```GetPinnableReference```, который
возвращает ```ref T``` или ```ref readonly T```, можно зафиксировать
(```GetPinnableReference``` должен преобразовывать переменную ```ref``` в
неуправляемый тип).
___________________________________________________________________
##			"Расширенные универсальные ограничения"

Можно указать тип ```System.Enum``` или ```System.Delegate``` в качестве
ограничения базового класса для параметра типа.

Доступно новое ограничение ```unmanaged```, чтобы указать, что параметр
типа должен быть неуправляемым типом.

#### ```Неуправляемый тип``` – это тип, который не является ссылочным и не ####
#### содержит ни одного ссылочного типа на любом уровне вложения. ####
___________________________________________________________________
#### УЛУЧШЕНИЕ СУЩЕСТВУЮЩИХ ФУНКЦИЙ ####

##			"Поддержка ```==``` и ```!=``` для кортежей"

Типы кортежей в C# теперь поддерживают операторы ```==``` и ```!=``` работающие
путём сравнения каждого элемента левого аргумента с каждым
элементом правого аргумента по порядку.

Оператор ```==``` перестаёт сравнивать элементы, как только будет
обнаружена неравная пара.
Оператор ```!=``` перестаёт сравнивать элементы, как только будет
обнаружена равная пара.
```
var left  = (a: 5, b: 10);
var right = (a: 5, b: 10);
Console.WriteLine(left == right); // true
```

Если один из кортежей допускает значение ```NULL```, функция проверки
кортежей на равенство выполняет неявное преобразование:
```
var left = (a: 5, b: 10);
var right = (a: 5, b: 10);
(int a, int b)? nullableTuple = right;
Console.WriteLine(left == nullableTuple); // true
```
Дополнительно выполняется неявное преобразование каждого элемента
обоих кортежей (преобразования для использования форм, допускающих
значение ```NULL```, расширяющие преобразования и другие неявные
преобразования):
```
var left = (a: 5, b: 10);
(int? a, int? b) nullableMembers = (5, 10);
Console.WriteLine(left == nullableMembers); // true

(long a, long b) longTuple = (5, 10);
Console.WriteLine(left == longTuple); // true

(long a, int b) longFirst = (5, 10);
(int a, long b) longSecond = (5, 10);
Console.WriteLine(longFirst == longSecond); // true
```
Имена элементов кортежей не участвуют в тестах на равенство.
Если один из операндов является литералом кортежа с явными именами,
компилятор генерирует предупреждение:
```
(int a, string b) pair    = (1, "Hello");
(int z, string y) another = (1, "Hello");

// имена элементов не участвуют
Console.WriteLine(pair == another); // true
// литерал содержит различные имена участников
Console.WriteLine(pair == (z: 1, y: "Hello")); // warning
```
Кортежи могут содержать вложенные кортежи. Функция проверки
кортежей на равенство сравнивает "форму" каждого операнда по
вложенным кортежам:
```
(int, (int, int)) nestedTuple = (1, (2, 3));
Console.WriteLine(nestedTuple == (1, (2, 3)) ); // true
```
___________________________________________________________________
##			"Подключение атрибутов к резервным полям для автоматически реализуемых свойств"

