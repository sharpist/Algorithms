#			[C# 7.0](https://github.com/sharpist/C_Sharp/tree/master/7.0#c-70) | [C# 7.1](https://github.com/sharpist/C_Sharp/tree/master/7.1#c-71) | C# 7.2 | [C# 7.3](https://github.com/sharpist/C_Sharp/tree/master/7.3#c-73)
#### Содержание: ####

[Семантика ссылок с типами значений](https://github.com/sharpist/C_Sharp/tree/master/7.2#Семантика-ссылок-с-типами-значений)

* [Добавлен тип Span\<T\>](https://github.com/sharpist/C_Sharp/tree/master/7.2#Добавлен-тип-spant)

[Неконечные именованные аргументы](https://github.com/sharpist/C_Sharp/tree/master/7.2#Неконечные-именованные-аргументы)

[Начальные символы подчеркивания в числовых литералах](https://github.com/sharpist/C_Sharp/tree/master/7.2#Начальные-символы-подчеркивания-в-числовых-литералах)

[Модификатор доступа private protected](https://github.com/sharpist/C_Sharp/tree/master/7.2#Модификатор-доступа-private-protected)

___________________________________________________________________
##			"Семантика ссылок с типами значений"

Работа с типами значений с использованием семантики ссылок повышает
производительность за счёт использования минимального числа
операций копирования типов значений без выделения памяти в связи с
применением ссылочных типов.

#### В число новых возможностей входят: ####

* модификатор ```in``` для параметров, указывающий, что аргумент
передаётся по ссылке (доступной только для чтения), но не
изменяется вызываемым методом.

* модификатор ```ref readonly``` для возвращаемого значения метода,
указывающий, что метод возвращает значение по ссылке, но не
допускает операции записи в соответствующий объект.

* объявление ```readonly struct```, указывающее, что структура является
неизменяемой и должна передаваться в методы члена как параметр ```in```.

* объявление ```ref struct```, указывающее, что тип структуры обращается
напрямую к управляемой памяти и всегда должен обрабатываться с
выделением стека.

#### Модификатор ```in``` ####
Данные модификаторы указывают, что тип значения передаётся по
ссылке, предотвращая копирование, в противном случае – типы
значений копируются при передаче в вызываемый метод:

```out``` – метод должен задавать значение аргумента, используемого в
качестве этого параметра (аргументы должны быть изменены).

```ref``` – метод может задавать значение аргумента, используемого в
качестве этого параметра (аргументы могут быть изменены).

```in``` – метод не изменяет значение аргумента, используемого в
качестве этого параметра (аргументы не могут быть изменены).

```c#
// расстояние между двумя точками в трехмерном пространстве
static double CalculateDistance(in Point3D point1,
                                in Point3D point2)
{
    var xDifference = point1.X - point2.X;
    var yDifference = point1.Y - point2.Y;
    var zDifference = point1.Z - point2.Z;

    return Math.Sqrt(xDifference * xDifference +
                     yDifference * yDifference +
                     zDifference * zDifference);
}
```
Аргументами являются две структуры, каждая из которых содержит три
типа double (размер 8 байт), следовательно, каждый аргумент равен
24 байтам.
Указывая модификатор ```in```, этим аргументам передаётся 4- или
8-байтовая ссылка.
Модификатор ```in``` может применяться к любому члену, который принимает
параметры (методы, делегаты, лямбда-выражения, локальные функции,
индексаторы, операторы).
```
Некоторые аргументы типа struct могут иметь большой размер, и при
вызове методов в ограниченных циклах или критических путях кода
стоимость копирования этих структур имеет определяющее значение.

Методы объявляют параметры in, чтобы указать, что аргументы можно
безопасно передавать по ссылке, так как вызываемый метод не
изменяет состояние этого аргумента.
```

В отличие от аргументов ```ref``` и ```out```, аргумент параметра ```in```
поддерживает литеральные значения или константы. Кроме того, в
отличие от параметра ```ref``` или ```out```, не нужно применять модификатор ```in```
на точке вызова.
Две локальные переменные, передаются по ссылке:
```c#
var distance = CalculateDistance(pt1, pt2);
```
#### пропуск модификатора ```in``` в месте вызова сообщает компилятору, что ####
#### он может сделать копию аргумента по следующим причинам: ####
1. выполняется неявное преобразование из типа аргумента в тип
параметра (не преобразование идентичности из типа аргумента в тип
параметра).
2. аргумент является выражением, но не имеет известную переменную
хранения (свойства и другие выражения, возвращающие значения).
*аргумент должен представлять расположение, на которое можно
сослаться напрямую
3. существует перегрузка, которая отличается наличием или
отсутствием ```in```, перегрузка по значению подходит лучше.

Внутри вызываемого метода можно вызвать любой метод экземпляра,
который использует параметры передачи по значению. В этих
экземплярах создается копия параметра ```in```.
Допускается указать значения по умолчанию для любого параметра ```in```.
```c#
static double CalculateDistance(in Point3D point1,
                                in Point3D point2 = default)
{
    var xDifference = point1.X - point2.X;
    var yDifference = point1.Y - point2.Y;
    var zDifference = point1.Z - point2.Z;

    return Math.Sqrt(xDifference * xDifference +
                     yDifference * yDifference +
                     zDifference * zDifference);
}
```
#### ограничения для параметров ```in```: ####
1. ключевые слова ```in```, ```ref``` и ```out``` запрещено использовать в
асинхронных методах.
2. запрещено использовать в методах итератора (включают оператор
```yield return``` или ```yield break```).

#### Модификатор ```ref readonly``` ####
Уведомляет, что выполняется возврат ссылки на существующие данные,
но внесение изменений запрещено.
Чтобы защитить структуру от изменений, компилятор создает копию и с
её помощью вызывает ссылки на включённые члены – изменения будут
вноситься в защитную копию.
```c#
// поле origin структуры Point3D
private static Point3D origin = new Point3D();

// свойство только для чтения
public static ref readonly Point3D Origin
{
    get { return ref origin; }
}
```
Допускается копирование возвращаемого значения по ссылке на
существующие данные, при назначении его переменной, не объявленной
с модификатором ```ref readonly```.
```c#
var originValue = Point3D.Origin;
ref readonly var originReference = ref Point3D.Origin;
```
В первом назначении создаётся и назначается копия константы Origin.
Во втором – ссылка, которую изменить невозможно.

#### Объявление ```readonly struct``` ####
Создаёт неизменяемую структуру с целью передачи по ссылке только
для чтения.
#### В этом случае удаляются защитные копии, создаваемые при доступе к ####
#### членам структуры, используемым в качестве параметра ```in```. ####

Если применяется модификатор ```readonly``` в объявлении структуры все
члены экземпляра структуры являются ```readonly```; тип struct должен
быть неизменным.

Модификатор ```in``` может использоваться в любом месте, где
```readonly struct``` выступает в качестве аргумента.
Можно вернуть ```readonly struct``` как ```ref return``` при возвращении
объекта, время существования которого выходит за пределы области
действия метода, возвращающего этот объект.

Компилятор создает более эффективный код, когда вызываются члены
```readonly struct```, например, параметром ```in```, передаваемым по ссылке
методу члена, всегда является ссылка ```this```, а не копия приемника.
```c#
readonly public struct ReadonlyPoint3D
{
    public double X { get; }
    public double Y { get; }
    public double Z { get; }
    public ReadonlyPoint3D(double x, double y, double z)
    {
        this.X = x;
        this.Y = y;
        this.Z = z;
    }

    private static readonly ReadonlyPoint3D origin =
        new ReadonlyPoint3D();

    public static ref readonly ReadonlyPoint3D Origin
    {
        get { return ref origin; }
    }
}
```

#### Объявление ```ref struct``` ####
Вводит тип значения, который должен размещаться в стеке и никогда
не создаваться в куче в качестве члена другого класса.

Поддержка типа ```ref struct``` как выделенной в стеке переменной вводит
правила, применяемые ко всем типам ```ref struct```:

* ```ref struct``` не поддерживает упаковку, тип ```ref struct``` невозможно
присвоить переменной типа ```object```, ```dynamic``` или любому типу
интерфейса.

* ```ref struct``` невозможно объявить как член класса или обычной
структуры.

* невозможно объявить локальные переменные, которые являются типами
```ref struct``` в асинхронных методах. Их можно объявить в синхронных
методах, возвращающих ```Task```, ```Task<T>``` или типах ```Task```.

* локальные переменные ```ref struct``` невозможно объявить в итераторах.

* невозможно захватить переменные ```ref struct``` в лямбда-выражениях
или локальных функциях.

#### Объявление ```readonly ref struct``` ####
Объявление структуры как ```readonly ref``` сочетает в себе преимущества
и недостатки объявлений ```ref struct``` и ```readonly struct```.
```c#
readonly ref struct ReadOnlyRefPoint2D
{
    public int X { get; }
    public int Y { get; }

    public ReadOnlyRefPoint2D(int x, int y) => (X, Y) = (x, y);
}
```

#### Добавлен тип ```Span<T>``` ####
Был добавлен тип ```Span<T>```, который позволяет создать коллекцию
данных, хранимую в стеке, но доступ к которой осуществляется по
ссылке.
Тип ```Memory<T>``` является расширением типа ```Span<T>``` и используется для
потокобезопасного доступа по ссылке к коллекции хранимой в стеке.

```System.Span<T>``` – это новый тип значений в основе .NET. Который,
делает возможным представление сопредельных областей произвольной
памяти, независимо от того, связана ли эта память с управляемым
объектом, обеспечивается ли она нативным (машинным) кодом через
interop или находится в стеке.
При этом сохраняется безопасный доступ с такими эксплуатационными
характеристиками, как характеристики массивов.

```Span<T>``` является небольшим, но критически важным строительным
блоком для огромных усилий по обеспечению .NET API для разработки
высокопроизводительных серверных приложений с высокой
масштабируемостью.
В отличие от массивов, он может указывать на управляемую или
собственную память, или на память, выделенную в стеке:
```c#
// managed memory
var arrayMemory = new byte[100];
var arraySpan = new Span<byte>(arrayMemory);

// native memory
var nativeMemory = Marshal.AllocHGlobal(100);
Span<byte> nativeSpan;
unsafe
{
    nativeSpan = new Span<byte>(nativeMemory.ToPointer(), 100);
}
SafeSum(nativeSpan);
Marshal.FreeHGlobal(nativeMemory);

// stack memory
Span<byte> stackSpan = stackalloc byte[100];
SafeSum(stackSpan);
```

#### Таким образом, ```Span<T>``` является абстракцией по всем типам памяти, ####
#### доступным для .NET-программ: ####
```c#
// не имеет значения с каким видом памяти работает метод
static ulong SafeSum(Span<byte> bytes)
{
    ulong sum = 0;
    for (int i = 0; i < bytes.Length; i++)
        sum += bytes[i];

    return sum;
}
```

При обёртывании массива ```Span<T>``` не ограничивается указанием на
первый элемент массива. Он может указывать на любой поддиапазон.
Другими словами, он поддерживает резку.
```c#
var array = new byte[] { 1, 2, 3 };
var slice = new Span<byte>(array, start:1, length:2);
Console.WriteLine(slice[0]); // 2
```
Версия ```Span<T>``` только для чтения – ```ReadOnlySpan<T>``` требуется для
представления срезов неизменяемых и доступных только для чтения
структур, например System.String cрезы.

Например, создав ```Span<T>``` из массива:
```c#
var arr = new byte[10];
Span<byte> bytes = arr; // неявное приведение из T[] в Span<T>
```
Можно эффективно создать ```Span``` чтобы представить/указать только
подмножество этого массива, используя перегруженный метод
```Span<T>.Slice```.
Затем индексировать полученный результирующий ```Span``` для записи или
чтения данных в соответствующей уместной части исходного массива:
```c#
Span<byte> slicedBytes = bytes.Slice(start: 5, length: 2);
slicedBytes[0] = 42;
slicedBytes[1] = 43;
Assert.Equal(42, slicedBytes[0]);
Assert.Equal(43, slicedBytes[1]);
Assert.Equal(arr[5], slicedBytes[0]);
Assert.Equal(arr[6], slicedBytes[1]);
slicedBytes[2] = 44; // Throws IndexOutOfRangeException
bytes[2] = 45; // OK
Assert.Equal(arr[2], bytes[2]);
Assert.Equal(45, arr[2]);
```

```Span<T>``` реализован только для стека; точнее, это by-ref тип (как и
его поле в быстрой реализации). Это означает, что ```Span``` не может
быть упакован, не может отображаться как поле типа, отличного от
стека, и не может использоваться в качестве обобщённого аргумента.
Однако ```Span<T>``` может использоваться как тип аргументов метода или
возвращаемых значений.

```Span<T>``` поддерживает переинтерпретацию приведения к ```Span<byte>```. Он
также поддерживает небезопасные приведения между произвольными
примитивными типами. Причина этого ограничения заключается в том,
что некоторые процессоры не поддерживают эффективный невыровненный
доступ к памяти.

В отличие от ```T[]```, ```Span<T>``` не поддерживает ковариантные приведения,
т.е. приведение ```Span<Subtype>``` к ```Span<Basetype>```, не выполняются
проверки ковариации при хранении ссылок в экземплярах ```Span<T>```.

#### Особенности: ####

1. Принудительное ограничение типа только для стека.

* ```Span<T>``` и ```ReadOnlySpan<T>``` включены в набор встроенных типов
только для стека.

* любая другая структура, содержащая один из них, будет транзитивно
считаться типом только для стека.

* компилятор выдаст ошибку, если тип только стека используется в
запрещенном контексте, например, используется в качестве аргумента
типа, помещённого в кучу (упаковка, передается в асинхронный вызов,
используется в качестве поля класса и т.д.).

2. Языковая поддержка для закрепления.
```c#
Span<byte> buffer = ...
fixed(byte* pBuffer = buffer)
{
    ...
}
```

3. Синтаксис среза.

* ```Memory<T>```, ```Span<T>``` и ```ReadOnlySpan<T>``` допускают синтаксис среза.

4. Безопасный ```Span<T>``` stackalloc ([stackalloc](https://github.com/sharpist/C_Sharp/tree/master/Stackalloc#stackalloc)).
```c#
void SafeMethod()
{
    Span<byte> buffer = stackalloc byte[128];
    PrimitiveFormatter.TryFormat(buffer, DateTime.Now, ...);
}
```

5. Примитивное ограничение.

* возможность ограничивать параметры типа примитивными типами
(которые являются битными), некоторые операции ```Span<T>``` допустимы
только для так называемых аргументов примитивного типа, например,
операция переинтерпретации приведения.
```c#
// операция приведения ограничивает параметры типа
public static Span<U> Cast<T, U>(this Span<T> slice) where T:primitive where U:primitive
{ ... }
```
___________________________________________________________________
##			"Неконечные именованные аргументы"

#### Именованные аргументы при использовании с позиционными доступны: ####

* если за ними не следуют позиционные аргументы.
```c#
PrintOrderDetails("Gift Shop", 31, productName: "Red Mug");
```
* или аргументы используются в правильной позиции.
```c#
PrintOrderDetails("Gift Shop", orderNum: 31, "Red Mug");
PrintOrderDetails(sellerName: "Gift Shop", 31, productName: "Red Mug");
```
*внеочередные именованные аргументы недопустимы, если за ними
следуют позиционные аргументы
___________________________________________________________________
##			"Начальные символы подчеркивания в числовых литералах"

Теперь шестнадцатеричные и двоичные числовые литералы могут
начинаться со знака ```_```.

```0b``` в начале константы означает, что число записано в двоичном
формате:
```c#
public const int binaryValue = 0b_0101_0101; // 85
public const int binaryValue2 = 0b0010_0000; // 32
```
___________________________________________________________________
##			"Модификатор доступа private protected"

Разрешает доступ для производных классов в одной сборке – доступ к
члену может осуществляться содержащим классом или производными
классами, которые объявлены ! в рамках одной сборки.

#### Модификаторы доступа: ####

* ```public``` неограниченный доступ.

* ```protected``` доступ ограничен содержащим классом или типами,
которые являются производными от содержащего класса.

* ```internal``` доступ ограничен текущей сборкой.

* ```protected internal``` доступ ограничен текущей сборкой или типами,
которые являются производными от содержащего класса.

* ```private``` доступ ограничен содержащим типом.

* ```private protected``` доступ ограничен содержащим классом или
типами, которые являются производными от содержащего класса в
текущей сборке.
