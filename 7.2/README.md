#			[C# 7.0](https://github.com/sharpist/C_Sharp/tree/master/7.0#c-70) | [C# 7.1](https://github.com/sharpist/C_Sharp/tree/master/7.1#c-71) | C# 7.2 | [C# 7.3](https://github.com/sharpist/C_Sharp/tree/master/7.3#c-73)
#### Содержание: ####

[Семантика ссылок с типами значений](https://github.com/sharpist/C_Sharp/tree/master/7.2#Семантика-ссылок-с-типами-значений)

* [Модификатор in](https://github.com/sharpist/C_Sharp/tree/master/7.2#Модификатор-in)

* [Модификатор ref readonly](https://github.com/sharpist/C_Sharp/tree/master/7.2#Модификатор-ref-readonly)

* [Объявление readonly struct](https://github.com/sharpist/C_Sharp/tree/master/7.2#Объявление-readonly-struct)

* [Объявление ref struct](https://github.com/sharpist/C_Sharp/tree/master/7.2#Объявление-ref-struct)

* [Объявление readonly ref struct](https://github.com/sharpist/C_Sharp/tree/master/7.2#Объявление-readonly-ref-struct)

* [Добавлен тип Span\<T\>](https://github.com/sharpist/C_Sharp/tree/master/7.2#Добавлен-тип-spant)

[Неконечные именованные аргументы](https://github.com/sharpist/C_Sharp/tree/master/7.2#Неконечные-именованные-аргументы)

[Начальные символы подчеркивания в числовых литералах](https://github.com/sharpist/C_Sharp/tree/master/7.2#Начальные-символы-подчеркивания-в-числовых-литералах)

[Модификатор доступа private protected](https://github.com/sharpist/C_Sharp/tree/master/7.2#Модификатор-доступа-private-protected)

___________________________________________________________________
##			"Семантика ссылок с типами значений"

Работа с типами значений с использованием семантики ссылок повышает
производительность за счёт использования минимального числа
операций копирования типов значений без выделения памяти в связи с
применением ссылочных типов.

#### В число новых возможностей входят: ####

* модификатор ```in``` для параметров, указывающий, что аргумент
передаётся по ссылке (доступной только для чтения), но не
изменяется вызываемым методом.

* модификатор ```ref readonly``` для возвращаемого значения метода,
указывающий, что метод возвращает значение по ссылке, но не
допускает операции записи в соответствующий объект.

* объявление ```readonly struct```, указывающее, что структура является
неизменяемой и должна передаваться в методы члена как параметр ```in```.

* объявление ```ref struct```, указывающее, что тип структуры обращается
напрямую к управляемой памяти и всегда должен обрабатываться с
выделением стека.

#### Модификатор ```in``` ####
Данные модификаторы указывают, что тип значения передаётся по
ссылке, предотвращая копирование, в противном случае – типы
значений копируются при передаче в вызываемый метод:

```out``` – метод должен задавать значение аргумента, используемого в
качестве этого параметра (аргументы должны быть изменены).

```ref``` – метод может задавать значение аргумента, используемого в
качестве этого параметра (аргументы могут быть изменены).

```in``` – метод не изменяет значение аргумента, используемого в
качестве этого параметра (аргументы не могут быть изменены).

*Переменные, передаваемые в качестве аргументов ```in```, требуется инициализировать
перед передачей в вызов метода. Но вызванный метод не может присвоить значение
или изменить аргумент.*

```c#
// расстояние между двумя точками в трехмерном пространстве
static double CalculateDistance(in Point3D point1,
                                in Point3D point2)
{
    var xDifference = point1.X - point2.X;
    var yDifference = point1.Y - point2.Y;
    var zDifference = point1.Z - point2.Z;

    return Math.Sqrt(xDifference * xDifference +
                     yDifference * yDifference +
                     zDifference * zDifference);
}
```
Аргументами являются две структуры, каждая из которых содержит три
типа double (размер 8 байт), следовательно, каждый аргумент равен
24 байтам.
Указывая модификатор ```in```, этим аргументам передаётся 4- или
8-байтовая ссылка.
Модификатор ```in``` может применяться к любому члену, который принимает
параметры (методы, делегаты, лямбда-выражения, локальные функции,
индексаторы, операторы).
```
Некоторые аргументы типа ```struct``` могут иметь большой размер, и при
вызове методов в ограниченных циклах или критических путях кода
стоимость копирования этих структур имеет определяющее значение.

Методы объявляют параметры ```in```, чтобы указать, что аргументы можно
безопасно передавать по ссылке, так как вызываемый метод не
изменяет состояние этого аргумента.
```

В отличие от аргументов ```ref``` и ```out```, аргумент параметра ```in```
поддерживает литеральные значения или константы. Кроме того, в
отличие от параметра ```ref``` или ```out```, не нужно применять модификатор ```in```
на точке вызова.
Две локальные переменные, передаются по ссылке:
```c#
var distance = CalculateDistance(pt1, pt2);
```
#### пропуск модификатора ```in``` в месте вызова сообщает компилятору, что ####
#### он может сделать копию аргумента по следующим причинам: ####
1. выполняется неявное преобразование из типа аргумента в тип
параметра (не преобразование идентичности из типа аргумента в тип
параметра).
2. аргумент является выражением, но не имеет известную переменную
хранения (свойства и другие выражения, возвращающие значения).
*аргумент должен представлять расположение, на которое можно
сослаться напрямую
3. существует перегрузка, которая отличается наличием или
отсутствием ```in```, перегрузка по значению подходит лучше.

Внутри вызываемого метода можно вызвать любой метод экземпляра,
который использует параметры передачи по значению. В этих
экземплярах создается копия параметра ```in```.
Допускается указать значения по умолчанию для любого параметра ```in```.
```c#
static double CalculateDistance(in Point3D point1,
                                in Point3D point2 = default)
{
    var xDifference = point1.X - point2.X;
    var yDifference = point1.Y - point2.Y;
    var zDifference = point1.Z - point2.Z;

    return Math.Sqrt(xDifference * xDifference +
                     yDifference * yDifference +
                     zDifference * zDifference);
}
```
#### ограничения для параметров ```in```: ####
1. ключевые слова ```in```, ```ref``` и ```out``` запрещено использовать в
асинхронных методах.
2. запрещено использовать в методах итератора (включают оператор
```yield return``` или ```yield break```).

#### Модификатор ```ref readonly``` ####
Уведомляет, что выполняется возврат ссылки на существующие данные,
но внесение изменений запрещено.
Чтобы защитить структуру от изменений, компилятор создает копию и с
её помощью вызывает ссылки на включённые члены – изменения будут
вноситься в защитную копию.
```c#
// поле origin структуры Point3D
private static Point3D origin = new Point3D();

// свойство только для чтения
public static ref readonly Point3D Origin
{
    get { return ref origin; }
}
```
Допускается копирование возвращаемого значения по ссылке на
существующие данные, при назначении его переменной, не объявленной
с модификатором ```ref readonly```.
```c#
var originValue = Point3D.Origin;
ref readonly var originReference = ref Point3D.Origin;
```
В первом назначении создаётся и назначается копия константы Origin.
Во втором – ссылка, которую изменить невозможно.

#### Объявление ```readonly struct``` ####
Создаёт неизменяемую структуру с целью передачи по ссылке только
для чтения.
#### В этом случае удаляются защитные копии, создаваемые при доступе к ####
#### членам структуры, используемым в качестве параметра ```in```. ####

Если применяется модификатор ```readonly``` в объявлении структуры все
члены экземпляра структуры являются ```readonly```; тип struct должен
быть неизменным.

Модификатор ```in``` может использоваться в любом месте, где
```readonly struct``` выступает в качестве аргумента.
Можно вернуть ```readonly struct``` как ```ref return``` при возвращении
объекта, время существования которого выходит за пределы области
действия метода, возвращающего этот объект.

Компилятор создает более эффективный код, когда вызываются члены
```readonly struct```, например, параметром ```in```, передаваемым по ссылке
методу члена, всегда является ссылка ```this```, а не копия приемника.
```c#
readonly public struct ReadonlyPoint3D
{
    public double X { get; }
    public double Y { get; }
    public double Z { get; }
    public ReadonlyPoint3D(double x, double y, double z)
    {
        this.X = x;
        this.Y = y;
        this.Z = z;
    }

    private static readonly ReadonlyPoint3D origin =
        new ReadonlyPoint3D();

    public static ref readonly ReadonlyPoint3D Origin
    {
        get { return ref origin; }
    }
}
```

#### Объявление ```ref struct``` ####
Вводит тип значения, который должен размещаться в стеке и никогда
не создаваться в куче в качестве члена другого класса.

Поддержка типа ```ref struct``` как выделенной в стеке переменной вводит
правила, применяемые ко всем типам ```ref struct```:

* ```ref struct``` не поддерживает упаковку, тип ```ref struct``` невозможно
присвоить переменной типа ```object```, ```dynamic``` или любому типу
интерфейса.

* ```ref struct``` невозможно объявить как член класса или обычной
структуры.

* невозможно объявить локальные переменные, которые являются типами
```ref struct``` в асинхронных методах. Их можно объявить в синхронных
методах, возвращающих ```Task```, ```Task<T>``` или типах ```Task```.

* локальные переменные ```ref struct``` невозможно объявить в итераторах.

* невозможно захватить переменные ```ref struct``` в лямбда-выражениях
или локальных функциях.

#### Объявление ```readonly ref struct``` ####
Объявление структуры как ```readonly ref``` сочетает в себе преимущества
и недостатки объявлений ```ref struct``` и ```readonly struct```.
```c#
readonly ref struct ReadOnlyRefPoint2D
{
    public int X { get; }
    public int Y { get; }

    public ReadOnlyRefPoint2D(int x, int y) => (X, Y) = (x, y);
}
```

#### Добавлен тип ```Span<T>``` ####
Был добавлен тип ```Span<T>``` ([Span\<T\>](https://github.com/sharpist/C_Sharp/tree/master/Span#spant)), который позволяет создать коллекцию
данных, хранимую в стеке, но доступ к которой осуществляется по
ссылке.
Тип ```Memory<T>``` является расширением типа ```Span<T>``` и используется для
потокобезопасного доступа по ссылке к коллекции хранимой в стеке.

```System.Span<T>``` – это новый тип значений в основе .NET. Который,
делает возможным представление сопредельных областей произвольной
памяти, независимо от того, связана ли эта память с управляемым
объектом, обеспечивается ли она нативным (машинным) кодом,
вызываемым из управляемого кода с помощью Interop или находится в
стеке.
При этом сохраняется безопасный доступ с такими эксплуатационными
характеристиками, как характеристики массивов.

В отличие от массивов, он может указывать на управляемую или
нативную память, или на память, выделенную в стеке:
```c#
// managed memory
var arrayMemory = new byte[100];
var arraySpan = new Span<byte>(arrayMemory);

// native memory
var nativeMemory = Marshal.AllocHGlobal(100);
Span<byte> nativeSpan;
unsafe
{
    nativeSpan = new Span<byte>(nativeMemory.ToPointer(), 100);
}
SafeSum(nativeSpan);
Marshal.FreeHGlobal(nativeMemory);

// stack memory
Span<byte> stackSpan = stackalloc byte[100];
SafeSum(stackSpan);
```

#### Таким образом, ```Span<T>``` является абстракцией по всем типам памяти, ####
#### доступным для .NET-программ: ####
```c#
// не имеет значения с каким видом памяти работает метод
static ulong SafeSum(Span<byte> bytes)
{
    ulong sum = 0;
    for (int i = 0; i < bytes.Length; i++)
        sum += bytes[i];

    return sum;
}
```

При обёртывании массива ```Span<T>``` не ограничивается указанием на
первый элемент массива. Он может указывать на любой поддиапазон.
Другими словами, он поддерживает резку:
```c#
var array = new byte[] { 1, 2, 3 };
var slice = new Span<byte>(array, start:1, length:2);
Console.WriteLine(slice[0]); // 2
```
___________________________________________________________________
##			"Неконечные именованные аргументы"

#### Именованные аргументы при использовании с позиционными доступны: ####

* если за ними не следуют позиционные аргументы.
```c#
PrintOrderDetails("Gift Shop", 31, productName: "Red Mug");
```
* или аргументы используются в правильной позиции.
```c#
PrintOrderDetails("Gift Shop", orderNum: 31, "Red Mug");
PrintOrderDetails(sellerName: "Gift Shop", 31, productName: "Red Mug");
```
*внеочередные именованные аргументы недопустимы, если за ними
следуют позиционные аргументы
___________________________________________________________________
##			"Начальные символы подчеркивания в числовых литералах"

Теперь шестнадцатеричные и двоичные числовые литералы могут
начинаться со знака ```_```.

```0b``` в начале константы означает, что число записано в двоичном
формате:
```c#
public const int binaryValue = 0b_0101_0101; // 85
public const int binaryValue2 = 0b0010_0000; // 32
```
___________________________________________________________________
##			"Модификатор доступа private protected"

Разрешает доступ для производных классов в одной сборке – доступ к
члену может осуществляться содержащим классом или производными
классами, которые объявлены ! в рамках одной сборки.

#### Модификаторы доступа: ####

* ```public``` неограниченный доступ.

* ```protected``` доступ ограничен содержащим классом или типами,
которые являются производными от содержащего класса.

* ```internal``` доступ ограничен текущей сборкой.

* ```protected internal``` доступ ограничен текущей сборкой или типами,
которые являются производными от содержащего класса.

* ```private``` доступ ограничен содержащим типом.

* ```private protected``` доступ ограничен содержащим классом или
типами, которые являются производными от содержащего класса в
текущей сборке.
