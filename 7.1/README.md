#			C# 7.1
#### Содержание: ####

[Выбор версии языка C#](https://github.com/sharpist/C_Sharp/tree/master/7.1#Выбор-версии-языка-c)

[async метод Main](https://github.com/)

...

___________________________________________________________________
##			"Выбор версии языка C#"

```
В C# 7.1 можно настроить компилятор в соответствии с указанной
версией языка (по умолчанию используется последняя доступная
основная версия языка), добавлен элемент конфигурации выбора версии
языка, в каждом проекте можно использовать определенную версию
языка для сборки.
```
#### Способы задания языковой версии: ####

* быстрое действие Visual Studio – отображает возможное решение для
изменения версии языка проекта, при использовании функции языка,
которая недоступна.

* из пользовательского интерфейса Visual Studio – узел проекта =>
Свойства => Сборка => Дополнительно
Необходимо задать явным образом для каждой конфигурации сборки. В
CSPROJ-файле следующий код:
```
<PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|AnyCPU'">
 <LangVersion>latest</LangVersion>
</PropertyGroup>

<PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|AnyCPU'">
 <LangVersion>latest</LangVersion>
</PropertyGroup>
```

* версию языка можно задать в CSPROJ-файле:
```latest``` использует последнюю дополнительную версию языка
```default``` возможно использование любого допустимого синтаксиса языка
из последней основной версии
```7``` принимается только синтаксис, включенный в спецификацию C# 7.0
или более ранней версии
```7.3``` принимается только синтаксис, включенный в спецификацию C# 7.3
или более ранней версии
```
<PropertyGroup>
   <LangVersion>latest</LangVersion>
</PropertyGroup>
```

* настройка нескольких проектов создав в каталоге решения файл
Directory.build.props (сборки в каждом подкаталоге каталога,
содержащего этот файл, будут использовать синтаксис C# версии 7.3)
со следующим кодом:
```
<Project>
 <PropertyGroup>
   <LangVersion>7.3</LangVersion>
 </PropertyGroup>
</Project>
```

* использовать параметр командной строки ```-langversion:latest```.
___________________________________________________________________
##			"async метод Main"

Точка входа для приложения может иметь модификатор async:
```
static async Task<int> Main()
{
    return await DoAsyncWork();
}
```
```
static async Task Main()
{   // если программа не возвращает код выхода
    await SomeAsyncMethod();
}
```

Устаревший способ:
```
static int Main()
{
    return DoAsyncWork().GetAwaiter().GetResult();
}
```
___________________________________________________________________
##			"Литеральные выражения по умолчанию"

Это усовершенствование выражения значения по умолчанию, которые
инициализируют переменную до значения по умолчанию.

Теперь можно опустить тип с правой стороны инициализации:
```
Func<string, bool> whereClause = default;
```

Устаревший способ:
```
Func<string, bool> whereClause = default(Func<string, bool>);
```

При заданной переменной ```t``` параметризованного типа ```T``` оператор
```default(T)``` разрешает инициализацию ссылочных типов, типов числовых
значений и структур.

Выражения значения по умолчанию можно использовать с управляемыми
типами:
```
var s = default(string);
var d = default(dynamic);
var i = default(int);
var n = default(int?); // n объект на основе типа, допускающего
                       // NULL-значение, где HasValue = false
```
___________________________________________________________________
##			"Выводимые имена элементов кортежа"

Часто при инициализации кортежа переменные в правой части задания
совпадают с именами для элементов кортежа:
```
int count = 5;
string label = "Colors used in the map";

var pair = (count: count, label: label);
```

В таком случае, имена элементов кортежа можно вывести (получить)
из переменных, используемых для инициализации кортежа:
```
int count = 5;
string label = "Colors used in the map";

var pair = (count, label); // элементы называются "count" и "label"
```
___________________________________________________________________
##			"Создание базовой сборки"

Два параметра компилятора ```-refout``` и ```-refonly``` (являются
взаимоисключающими), которые создают сборки для справки:

* параметр ```-refout:filepath``` указывает путь к файлу, в который нужно
выводить базовую сборку, где filepath – путь к файлу базовой
сборки.
```
Базовую сборку следует помещать во вложенную папку ref/
относительно основной сборки.
```

* параметр ```-refonly``` указывает, что в качестве основных выходных
данных должна быть выведена базовая сборка, а не сборка реализации.
